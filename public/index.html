<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <meta name="description" content="Web site created using create-react-app" />
  <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
  <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
  <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
  <title>React App</title>
</head>

<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
  <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  <script>
    window.addEventListener('load', () => {
      const scroll = document.querySelector('.smooth-scroll-wrapper');
      const pxPerScroll = 100;
      let y = 0;
      let actualCoordY = scroll.getBoundingClientRect().top;
      const initialCoordY = scroll.getBoundingClientRect().top;
      const initialLimit = 0;
      const finalLimit = document.body.scrollHeight;


      //animacion para el texto
      let transX = {
        value: (window.innerWidth >= 1600) ? -300
        : (window.innerWidth >= 1400) ? -200
        : (window.innerWidth >= 1200) ? -150 
        : (window.innerWidth >= 1000) ? -100
        : 0
      }
      const leftLimitText = transX;
      const rightLimitText = 0;

      const text = document.querySelector(".my-who__text");
      const textCoordYTop = text.getBoundingClientRect().top;
      const textCoordYBottom = text.getBoundingClientRect().bottom;
      const necessaryScrollMoves_my_who_text =  (window.innerHeight + (textCoordYBottom - textCoordYTop)) / pxPerScroll;
      console.log('necessaryScrollMoves_my_who_text', necessaryScrollMoves_my_who_text)
      const transXValue = Math.abs(transX.value) / necessaryScrollMoves_my_who_text;
      //circle
      const circleText = document.querySelector("#circle__text-container--2");
      const circleTextServices = document.querySelector("#circle__text-container--1");
      //creamos objeto en vez de variable ya que es de las pocas formas de enviar referencia en vez del valor por parametros 
      let circleRotate = {
          value: 0
      };
      let circleRotate2 = {
        value: 0
    };
      const circleTextYTop = circleTextServices.getBoundingClientRect().top;
      const circleTextYBottom = circleTextServices.getBoundingClientRect().bottom;
      const circleTextYTop2 = circleText.getBoundingClientRect().top;
      const circleTextYBottom2 = circleText.getBoundingClientRect().bottom;
      const circleValue = 40;
      //slider
      const slider = document.querySelector(".slider");
      const swiper_1 = document.querySelector(".swiper-1");
      const swiper_2 = document.querySelector(".swiper-2");
      const sliderYTop = slider.getBoundingClientRect().top;
      const sliderYBottom = slider.getBoundingClientRect().bottom;
       ///variables necesarias para poder calcular en cuantos scrolleos ya no se verá la seccion my-who__content
      const my_who_content = document.querySelector(".my-who__content");
      const my_who_contentTop = my_who_content.getBoundingClientRect().top;
      const my_who_contentBottom = my_who_content.getBoundingClientRect().bottom;
      const necessaryScrollMoves_my_who =  (window.innerHeight + (my_who_contentBottom - my_who_contentTop)) / pxPerScroll

      let sliderValue = {
        value: (window.innerWidth >= 1000) ? -250
        : (window.innerWidth < 1000 && window.innerWidth > 700) ? -150
        : (window.innerWidth <= 700 && window.innerWidth > 500) ? -100
        : -80 
      };
      //const slideValue = 10;
      const slideValue = Math.abs(sliderValue.value) / necessaryScrollMoves_my_who;
      
       //variable para calcular dinamicamente la mitad del width de la pantalla
       const halfviewportWidth = window.innerWidth / 2;

      //las secciones de servicios que se abren
      const rowServiceHeight = 300;
      const rowServices1 = document.querySelectorAll('.services__row')[0];
      const rowServices1YTop = rowServices1.getBoundingClientRect().top;
      const rowServices1YBottom = rowServices1.getBoundingClientRect().top + (rowServiceHeight / 2);
      const rowServicesLimitBottom = y + halfviewportWidth;

      const rowServices2 = document.querySelectorAll('.services__row')[1];
      const rowServices2YTop = rowServices2.getBoundingClientRect().top;
      const rowServices2YBottom = rowServices2.getBoundingClientRect().top + (rowServiceHeight / 2);


      const rowServices3 = document.querySelectorAll('.services__row')[2];
      const rowServices3YTop = rowServices3.getBoundingClientRect().top;
      const rowServices3YBottom = rowServices3.getBoundingClientRect().top + (rowServiceHeight / 2);

      const rowServices4 = document.querySelectorAll('.services__row')[3];
      const rowServices4YTop = rowServices4.getBoundingClientRect().top;
      const rowServices4YBottom = rowServices4.getBoundingClientRect().top + (rowServiceHeight / 2);
      
      const serviceItem0 = document.querySelector('.services__item--0');
      const serviceItem1= document.querySelector('.services__item--purple-0');
      const serviceItem2 = document.querySelector('.services__item--1');
      const serviceItem3= document.querySelector('.services__item--purple-1');
      const serviceItem4 = document.querySelector('.services__item--2');
      const serviceItem5= document.querySelector('.services__item--purple-2');
      const serviceItem6 = document.querySelector('.services__item--3');
      const serviceItem7 = document.querySelector('.services__item--purple-3');
      const translateRow1 = {
        value:0
      };
      const translateRow2 = {
        value:0
      };
      const translateRow3 = {
        value:0
      };
      const translateRow4 = {
        value:0
      };

      let reachedLimitBottom = false;

      let necessaryScrollMoves = ((rowServices1YTop + (rowServiceHeight/2)) - (rowServices1YTop - (window.innerHeight / 2))) / pxPerScroll;
      if((necessaryScrollMoves - Math.floor(necessaryScrollMoves)) !== 0) necessaryScrollMoves =  Math.round(necessaryScrollMoves) + 1;

      let translateRowValue = ((window.innerWidth / 2) / 2) / necessaryScrollMoves;
      console.log(Math.round(necessaryScrollMoves))
      console.log('necessaryScrollMoves', necessaryScrollMoves);

      const myName = document.querySelector(".nav__text");
      const myNameYTop = myName.getBoundingClientRect().top;
      const myNameYBottom = myName.getBoundingClientRect().bottom;
      const scaleValue = 0.15;
      const opacityValue = 0.35;
      const properties = {
        scale:1,
        opacity:1
      }


      //variable para igualar el valor de Y para que llegue exactamente al final de la pagina
      const documentHeight = document.body.scrollHeight - window.innerHeight;

      function debounce(func, wait, immediate) {
        var timeout;
        return function () {
          var context = this, args = arguments;
          var later = function () {
            timeout = null;
            if (!immediate) func.apply(context, args);
          };
          var callNow = immediate && !timeout;
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
          if (callNow) func.apply(context, args);
        };
      };


      var delay = 1; // 1s

      var handlerFunction = debounce(function (e) {

      }, delay);
      document.addEventListener("wheel", handlerFunction)



      const animation = (e, y) => {
        if (textCoordYTop < (Math.abs(y) + window.innerHeight) && textCoordYBottom > (Math.abs(y))) {
          if (e.wheelDelta < 0 && (transX + transXValue) < rightLimitText ) {
            transX -= transXValue;
          }
          else if(e.wheelDelta > 0 && (transX - transXValue) > leftLimitText ){
            transX += transXValue;
          }
        } else if (textCoordYBottom < ((Math.abs(y) - pxPerScroll) + window.innerHeight) && textCoordYBottom > (Math.abs(y) - pxPerScroll)) {
          alert('1')
          if (e.wheelDelta > 0)
            transX -= transXValue;
        }
        text.style.transform = "translateX(" + transX + "px)";
      }

      const circleAnimation = (wheelDelta, y, element, coordYTop, coordYBottom, transform, obj, value, element2 = null, element3 = null, limitTop = Math.abs(y), limitBottom = (Math.abs(y) + window.innerHeight)) => {
        if (wheelDelta < 0 && coordYTop < (limitBottom + pxPerScroll) && coordYBottom > limitTop) {
         obj.value += value;
         console.log('entra1')
         console.log('value',value)
         console.log('obj.value1', obj.value)
        }else if(wheelDelta > 0 && coordYTop < limitBottom && coordYBottom > limitTop){
          obj.value -= value;
          console.log('entra2')
        }else if (coordYBottom < (limitBottom - pxPerScroll) && coordYBottom > (limitTop - pxPerScroll)) {
          console.log('entra3')
          if(wheelDelta > 0)
            obj.value -= value;
        }
        const unit = (transform === 'translateX') ? 'px' : 'deg';
        if(element2 === null){
          element.style.transform =  transform + "(" + parseInt(obj.value) + unit + ")";
        }else if(element2.classList.contains('services__item')){
          if(obj.value > (halfviewportWidth / 2)) obj.value = (halfviewportWidth / 2);
          if(obj.value < 0) obj.value = 0;
          element3.style.transform = transform + "(" + parseInt(obj.value) + unit + ")";
          element2.style.transform =  transform + "(" + (parseInt(obj.value) * -1) + unit + ")";
        }
        else{
          //entra aquí con es el swiper
          
          /*if(obj.value > 0) obj.value = 0;
          else if(obj.value < -300) obj.value = -300;*/
          element2.style.transform =  transform + "(" + parseInt(obj.value) + unit + ")";
          element3.style.transform =  transform + "(" + (parseInt(obj.value) * -1) + unit + ")";
        }
      console.log('obj.value', obj.value)
      console.log('obj', obj)
      }

      const servicesAnimation = (wheelDelta, y, element, coordYTop, coordYBottom, transform, obj, value, animatedElement1, animatedElement2 , limitTop = Math.abs(y), limitBottom = (Math.abs(y) + window.innerHeight)) => {
        if (wheelDelta < 0 && coordYTop < (limitBottom + pxPerScroll) && coordYBottom > limitTop) {
          //(Math.abs(y) - pxPerScroll) le añado nuevo el -pxperscroll 
          if(coordYBottom > ((Math.abs(y) - pxPerScroll)  + (window.innerHeight / 2))){
             obj.value += value;
          }
         }else if(wheelDelta > 0 && coordYTop < limitBottom && coordYBottom > limitTop){

          //el 150 está hardcodeado
          if((coordYTop + 150) > ((Math.abs(y) - pxPerScroll) + (window.innerHeight / 2))){

            //el problema q existe es que no se contrae en la misma posicion en la que se expande, tarda 1 scroll más en contraerse
            obj.value -= value;
          } 
         }
         const unit = (transform === 'translateX') ? 'px' : 'deg';
         
           if(obj.value < 0) obj.value = 0;
           else if(obj.value > (halfviewportWidth / 2)) obj.value = (halfviewportWidth / 2);
           
           animatedElement2.style.transform = transform + "(" + parseInt(obj.value) + unit + ")";
           animatedElement1.style.transform =  transform + "(" + (parseInt(obj.value) * -1) + unit + ")";
      }

      const disappearTextAnimation = (wheelDelta, y, element, coordYTop, coordYBottom, transform, obj, value) => {
        if (wheelDelta < 0 && coordYTop > Math.abs(y) && coordYBottom < (Math.abs(y) + window.innerHeight)){
          obj.scale -= value;
          obj.opacity -= opacityValue;
          if(obj.scale < 0) obj.scale = 0;
          if(obj.opacity < 0) obj.opacity = 0;
        }else if(wheelDelta > 0 && (Math.abs(y) - pxPerScroll) < coordYBottom){
          obj.scale += value;
          obj.opacity += opacityValue;
          if(obj.scale > 1) obj.scale = 1;
          if(obj.opacity > 1) obj.opacity = 1;
        }
        element.style.scale = `${obj.scale}`;
        element.style.opacity = `${obj.opacity}`;
        //element.style.transform = `translateY()`;
      }
      const smooth = debounce((e) => {
        circleAnimation(e.wheelDelta, y, text, textCoordYTop, textCoordYBottom, 'translateX', transX, transXValue);
        //animation(e, y);

        //falta meterle la animacion al texto 
        disappearTextAnimation(e.wheelDelta, y, myName, myNameYTop, myNameYBottom, 'scale', properties, scaleValue);
        //para que el circulo con texto no siga dando vueltas si se llega al final
        if(!reachedLimitBottom || e.wheelDelta > 0)
          circleAnimation(e.wheelDelta, y, circleText, circleTextYTop2, circleTextYBottom2, 'rotate', circleRotate2, circleValue);

        circleAnimation(e.wheelDelta, y, circleTextServices, circleTextYTop, circleTextYBottom, 'rotate', circleRotate, circleValue);

        circleAnimation(e.wheelDelta, y, slider, my_who_contentTop, my_who_contentBottom, 'translateX', sliderValue, slideValue, swiper_1, swiper_2);


        servicesAnimation(e.wheelDelta, y, rowServices1, rowServices1YTop, rowServices1YBottom, 'translateX', translateRow1, translateRowValue, serviceItem0, serviceItem1);
        servicesAnimation(e.wheelDelta, y, rowServices2, rowServices2YTop, rowServices2YBottom, 'translateX', translateRow2, translateRowValue, serviceItem2, serviceItem3);
        servicesAnimation(e.wheelDelta, y, rowServices3, rowServices3YTop, rowServices3YBottom, 'translateX', translateRow3, translateRowValue, serviceItem4, serviceItem5);
        servicesAnimation(e.wheelDelta, y, rowServices4, rowServices4YTop, rowServices4YBottom, 'translateX', translateRow4, translateRowValue, serviceItem6, serviceItem7);
        
        if (e.wheelDelta < 0 && y <= initialLimit && (Math.abs(y) + window.innerHeight) < finalLimit) {
          y -= pxPerScroll;
          if ((Math.abs(y) + window.innerHeight) > finalLimit) {
            //y += pxPerScroll;
            //aqui dentro no asigno valor a la i ya que dejaría de ser múltiplo de 10 o 100, por eso al translate le sumo y + la diferencia
            const yAux = (finalLimit - window.innerHeight);
            scroll.style.transform = "translateY(" + (-yAux) + "px)";
            reachedLimitBottom = true;
            return null;
          }
        } else if (e.wheelDelta > 0 && Math.abs(y) < finalLimit && y < 0) {
          console.log('entraaaaaaa');
          y += pxPerScroll;
          if (y > initialLimit) {
            y = 0;
          }
          reachedLimitBottom = false;
        }
        if(!reachedLimitBottom)
          scroll.style.transform = "translateY(" + y + "px)";
      }, delay);


      //para eliminar el smooth scroll en pantallas que no pertenezcan a pc
      if(window.innerWidth >= 768) document.body.addEventListener("wheel", smooth);
      //document.body.addEventListener("wheel", animation);
    })

  </script>
</body>

</html>